{"version":3,"file":"vue2-interact.esm.js","sources":["../src/interact-event-bus.js","../src/components/Vue2InteractDraggable.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/index.js"],"sourcesContent":["import Vue from 'vue';\n\nexport default new Vue();\n","<template>\n  <div\n    ref=\"interactElement\"\n    :class=\"{ 'vue-interact-animated': interactIsAnimating }\"\n    :style=\"{\n      transform: interactTransformString,\n      transition: interactTransitionString\n    }\"\n  >\n    <slot />\n  </div>\n</template>\n\n<script>\nimport interact from 'interact.js';\nimport InteractEventBus from '../interact-event-bus';\n\nexport default {\n  name: 'Vue2InteractDraggable',\n\n  props: {\n    interactBlockDragDown: {\n      type: Boolean,\n      default: false,\n    },\n    interactBlockDragLeft: {\n      type: Boolean,\n      default: false,\n    },\n    interactBlockDragRight: {\n      type: Boolean,\n      default: false,\n    },\n    interactBlockDragUp: {\n      type: Boolean,\n      default: false,\n    },\n    interactEventBusEvents: {\n      type: Object,\n      default: () => {},\n    },\n    interactMaxRotation: {\n      type: Number,\n      default: 0,\n    },\n    interactLockXAxis: {\n      type: Boolean,\n      default: false,\n    },\n    interactLockYAxis: {\n      type: Boolean,\n      default: false,\n    },\n    interactLockSwipeDown: {\n      type: Boolean,\n      default: false,\n    },\n    interactLockSwipeLeft: {\n      type: Boolean,\n      default: false,\n    },\n    interactLockSwipeRight: {\n      type: Boolean,\n      default: false,\n    },\n    interactLockSwipeUp: {\n      type: Boolean,\n      default: false,\n    },\n    interactOutOfSightXCoordinate: {\n      type: Number,\n      default: 500,\n    },\n    interactOutOfSightYCoordinate: {\n      type: Number,\n      default: 1000,\n    },\n    interactXThreshold: {\n      type: Number,\n      default: 200,\n    },\n    interactYThreshold: {\n      type: Number,\n      default: 300,\n    },\n  },\n\n  data() {\n    return {\n      interactIsAnimating: true,\n      interactDragged: null,\n      interactPosition: {\n        x: 0,\n        y: 0,\n        rotation: 0,\n      },\n    };\n  },\n\n  computed: {\n    interactTransformString() {\n      if (!this.interactIsAnimating || this.interactDragged) {\n        const { x, y, rotation } = this.interactPosition;\n        return `translate3D(${x}px, ${y}px, 0) rotate(${rotation}deg)`;\n      }\n\n      return null;\n    },\n\n    interactTransitionString() {\n      if (this.interactIsAnimating) return 'transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)';\n\n      return null;\n    },\n  },\n\n  watch: {\n    interactEventBusEvents(val) {\n      this.interactSetEventBusEvents();\n    },\n  },\n\n  mounted() {\n    this.interactSetEventBusEvents();\n\n    const element = this.$refs.interactElement;\n\n    interact(element).draggable({\n      onstart: () => {\n        this.interactIsAnimating = false;\n      },\n\n      onmove: (event) => {\n        let x = 0;\n        let y = 0;\n\n        if (this.interactLockSwipeLeft && event.dx < 0) x = 0;\n        else if (this.interactLockSwipeRight && event.dx > 0) x = 0;\n        else x = this.interactLockXAxis ? 0 : (this.interactPosition.x || 0) + event.dx;\n\n        if (this.interactLockSwipeUp && event.dy < 0) y = 0;\n        else if (this.interactLockSwipeDown && event.dy > 0) y = 0;\n        else y = this.interactLockYAxis ? 0 : (this.interactPosition.y || 0) + event.dy;\n\n        let rotation = this.interactMaxRotation * (x / this.interactXThreshold);\n\n        if (rotation > this.interactMaxRotation) rotation = this.interactMaxRotation;\n        else if (rotation < -this.interactMaxRotation) rotation = -this.interactMaxRotation;\n\n        this.interactSetPosition({ x, y, rotation });\n      },\n\n      onend: () => {\n        const { x: cardPositionX, y: cardPositionY } = this.interactPosition;\n        const { interactXThreshold, interactYThreshold } = this;\n        this.interactIsAnimating = true;\n\n        if (cardPositionX > interactXThreshold) this.interactDraggedRight();\n        else if (cardPositionX < -interactXThreshold) this.interactDraggedLeft();\n        else if (cardPositionY > interactYThreshold) this.interactDraggedDown();\n        else if (cardPositionY < -interactYThreshold) this.interactDraggedUp();\n        else this.interactResetCardPosition();\n      },\n    });\n  },\n\n  beforeDestroy() {\n    interact(this.$refs.interactElement).unset();\n    this.interactUnsetEventBusEvents();\n  },\n\n  methods: {\n    interactDraggedDown() {\n      if (this.interactBlockDragDown) {\n        this.interactResetCardPosition();\n        return;\n      }\n      this.interactUnsetElement();\n      this.interactSetPosition({ y: this.interactOutOfSightYCoordinate });\n      this.$emit('draggedDown');\n    },\n\n    interactDraggedLeft() {\n      if (this.interactBlockDragLeft) {\n        this.interactResetCardPosition();\n        return;\n      }\n      this.interactUnsetElement();\n      this.interactSetPosition({\n        x: -this.interactOutOfSightXCoordinate,\n        rotation: -this.interactMaxRotation,\n      });\n      this.$emit('draggedLeft');\n    },\n\n    interactDraggedRight() {\n      if (this.interactBlockDragRight) {\n        this.interactResetCardPosition();\n        return;\n      }\n      this.interactUnsetElement();\n      this.interactSetPosition({\n        x: this.interactOutOfSightXCoordinate,\n        rotation: this.interactMaxRotation,\n      });\n      this.$emit('draggedRight');\n    },\n\n    interactDraggedUp() {\n      if (this.interactBlockDragUp) {\n        this.interactResetCardPosition();\n        return;\n      }\n      this.interactUnsetElement();\n      this.interactSetPosition({ y: -this.interactOutOfSightYCoordinate });\n      this.$emit('draggedUp');\n    },\n\n    interactSetEventBusEvents() {\n      if (this.interactEventBusEvents) {\n        if (this.interactEventBusEvents.draggedDown) {\n          InteractEventBus.$on(this.interactEventBusEvents.draggedDown, this.interactDraggedDown);\n        };\n\n        if (this.interactEventBusEvents.draggedLeft) {\n          InteractEventBus.$on(this.interactEventBusEvents.draggedLeft, this.interactDraggedLeft);\n        };\n\n        if (this.interactEventBusEvents.draggedRight) {\n          InteractEventBus.$on(this.interactEventBusEvents.draggedRight, this.interactDraggedRight);\n        };\n\n        if (this.interactEventBusEvents.draggedUp) {\n          InteractEventBus.$on(this.interactEventBusEvents.draggedUp, this.interactDraggedUp);\n        };\n      }\n    },\n\n    interactSetPosition(coordinates) {\n      const {\n        x = 0,\n        y = 0,\n        rotation = 0\n      } = coordinates;\n\n      this.interactPosition = {x, y, rotation };\n    },\n\n    interactUnsetElement() {\n      interact(this.$refs.interactElement).unset();\n      this.interactDragged = true;\n    },\n\n    interactUnsetEventBusEvents() {\n      if (this.interactEventBusEvents) {\n        if (this.interactEventBusEvents.draggedDown) {\n          InteractEventBus.$off(this.interactEventBusEvents.draggedDown, this.draggedDown);\n        };\n\n        if (this.interactEventBusEvents.draggedLeft) {\n          InteractEventBus.$off(this.interactEventBusEvents.draggedLeft, this.draggedLeft);\n        };\n\n        if (this.interactEventBusEvents.draggedRight) {\n          InteractEventBus.$off(this.interactEventBusEvents.draggedRight, this.draggedRight);\n        };\n\n        if (this.interactEventBusEvents.draggedUp) {\n          InteractEventBus.$off(this.interactEventBusEvents.draggedUp, this.draggedUp);\n        };\n      }\n    },\n\n    interactResetCardPosition() {\n      this.interactSetPosition({ x: 0, y: 0, rotation: 0 });\n    }\n  },\n};\n</script>\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","import Vue2InteractDraggable from './components/Vue2InteractDraggable.vue'\nimport InteractEventBus from './interact-event-bus.js';\n\nconst plugin = {\n  install (Vue) {\n    Vue.component('Vue2InteractDraggable', Vue2InteractDraggable)\n  }\n}\n\nexport { Vue2InteractDraggable };\nexport { InteractEventBus };\n\n// Auto-install\nlet GlobalVue = null\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue\n}\nif (GlobalVue) {\n  GlobalVue.use(plugin)\n}\n"],"names":["Vue","plugin","component","Vue2InteractDraggable","GlobalVue","window","global","use"],"mappings":"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"}